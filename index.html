<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast Solver v4.1</title>
    <style>
        :root {
            --bg-color: #2C3E50;
            --board-bg: #34495E;
            --cell-empty: #ECF0F1;
            --cell-filled: #7F8C8D;
            --text-color: white;
            --modal-bg: rgba(44, 62, 80, 0.95);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overscroll-behavior: none; 
        }

        /* Ê®ôÈ°åËàáÈÅ∏ÂñÆÊåâÈàïÂçÄ */
        .header {
            width: 100%;
            max-width: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 15px;
        }

        h1 { margin: 0; font-size: 1.2rem; }

        .menu-btn {
            position: absolute;
            left: 0;
            background: #3498DB;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
            align-items: center;
            gap: 15px;
        }

        /* --- 1. Ê£ãÁõ§ÂçÄ --- */
        .board-wrapper {
            width: 95vw; 
            max-width: 500px;
            background-color: var(--board-bg);
            border-radius: 8px;
            padding: 5px;
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .board-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            display: none; 
        }
        .board-wrapper.locked .board-overlay { display: block; }

        .board-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1rem;
            color: white;
            user-select: none;
        }

        .cell.filled { background-color: var(--cell-filled); }
        .cell.preview { background-color: #00E676 !important; color: #000; box-shadow: inset 0 0 0 2px #fff; } 

        .controls {
            width: 95vw;
            max-width: 500px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            border: none;
            padding: 12px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.96); }
        .btn-undo { background-color: #95A5A6; color: white; }
        .btn-clear { background-color: #E74C3C; color: white; }
        
        .btn-solve { 
            background-color: #27AE60; color: white; 
            width: 100%; margin: 10px 0; font-size: 1.2rem; padding: 15px;
        }
        .btn-next { background-color: #F39C12; color: white; width: 100%; padding: 15px;}
        .btn-next:disabled { background-color: #555; opacity: 0.5; }

        /* --- 2. ÊñπÂ°äÊìç‰ΩúÂçÄ --- */
        .right-panel {
            width: 95vw;
            max-width: 500px;
            display: flex;
            flex-direction: column;
        }

        .panel-label { margin-bottom: 5px; font-size: 0.9rem; color: #BDC3C7; }

        .hand-area {
            background-color: var(--board-bg);
            height: 90px;
            border-radius: 8px;
            padding: 5px 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .hand-piece {
            position: relative;
            background: rgba(0,0,0,0.2);
            padding: 4px;
            border-radius: 4px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hand-piece .remove-btn {
            position: absolute;
            top: -8px; right: -8px;
            background: #E74C3C; color: white;
            border-radius: 50%;
            width: 22px; height: 22px;
            font-size: 14px;
            line-height: 22px;
            text-align: center;
            font-weight: bold;
            border: 2px solid var(--board-bg);
        }

        .status-msg {
            text-align: center;
            margin: 5px 0;
            min-height: 24px;
            color: #F1C40F;
            font-weight: bold;
        }

        /* --- 3. ÂΩàÂá∫ÂºèÊñπÂ°äÂ∫´ (Modal) --- */
        .library-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--modal-bg);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
            visibility: hidden;
            opacity: 0;
        }
        .library-modal.show { visibility: visible; opacity: 1; }

        .modal-header {
            width: 100%; max-width: 600px;
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px;
        }
        .close-btn {
            background: transparent; font-size: 2rem; color: white; padding: 0; box-shadow: none;
        }

        .category-title {
            width: 100%; max-width: 600px;
            color: #BDC3C7; font-size: 0.9rem; margin: 10px 0 5px 0; border-bottom: 1px solid #555;
        }

        .library-content {
            flex: 1;
            width: 100%; max-width: 600px;
            overflow-y: auto;
            padding-bottom: 50px;
        }

        .lib-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
        }

        .lib-piece {
            aspect-ratio: 1;
            background-color: rgba(255,255,255,0.1);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .lib-piece:active { transform: scale(0.9); background-color: rgba(255,255,255,0.3); }
        .lib-piece canvas { max-width: 85%; max-height: 85%; }

    </style>
</head>
<body>

    <div class="header">
        <button class="menu-btn" onclick="toggleLibrary()">‚ò∞ ÊñπÂ°äÂ∫´</button>
        <h1>Block Blast Solver</h1>
    </div>

    <div class="container">
        <div id="boardWrapper" class="board-wrapper">
            <div class="board-overlay"></div> <div id="board" class="board-container">
                </div>
        </div>
        
        <div class="controls">
            <button class="btn-undo" onclick="undoBoard()">‚Ü∫ ‰∏ä‰∏ÄÊ≠•</button>
            <button class="btn-clear" onclick="clearBoard()">üóë Ê∏ÖÁ©∫</button>
        </div>

        <div class="right-panel">
            <div id="status" class="status-msg"></div>
            
            <button class="btn-solve" onclick="runSolver()">‚ú® Ë®àÁÆóÊúÄ‰Ω≥Ëß£ ‚ú®</button>
            <button id="btnNext" class="btn-next" onclick="applyNextStep()" disabled>Âü∑Ë°åÈÄô‰∏ÄÊ≠• ‚ñ∂</button>

            <div class="panel-label" style="text-align: center; margin-top: 10px;">Êú¨Ëº™ÊñπÂ°ä (ÈªûÂ∑¶‰∏äËßíÊ∑ªÂä†)</div>
            <div id="hand" class="hand-area">
                <span style="color: #777; font-size: 0.9rem;">(Á©∫)</span>
            </div>
        </div>
    </div>

    <div id="libModal" class="library-modal">
        <div class="modal-header">
            <h2 style="margin:0">ÈÅ∏ÊìáÊñπÂ°ä</h2>
            <button class="close-btn" onclick="toggleLibrary()">√ó</button>
        </div>
        <div id="libContent" class="library-content">
            </div>
    </div>

<script>
// ==========================================
// 1. Ë≥áÊñôÂÆöÁæ©
// ==========================================
const SHAPES = {
    // Èªû
    '1': [[1]],
    // Áõ¥Á∑ö
    '2h': [[1,1]], '3h': [[1,1,1]], '4h': [[1,1,1,1]], '5h': [[1,1,1,1,1]],
    '2v': [[1],[1]], '3v': [[1],[1],[1]], '4v': [[1],[1],[1],[1]], '5v': [[1],[1],[1],[1],[1]],
    // ÊñúËßí
    'd2': [[1,0],[0,1]], 'd2_r': [[0,1],[1,0]],
    'd3': [[1, 0, 0], [0, 1, 0], [0, 0, 1]], 'd3_r': [[0, 0, 1], [0, 1, 0], [1, 0, 0]],
    // ÊñπÂ°ä
    '2x2': [[1,1],[1,1]], '2x3': [[1,1,1],[1,1,1]], '3x2': [[1,1],[1,1],[1,1]], '3x3': [[1,1,1],[1,1,1],[1,1,1]],
    // TÂûã
    'T3': [[1,1,1],[0,1,0]], 'T3_r': [[0,1],[1,1],[0,1]], 'T3_m': [[0,1,0],[1,1,1]], 'T3_mr': [[1,0],[1,1],[1,0]],
    // ZÂûã
    'z3': [[1, 1, 0], [0, 1, 1]], 'z3_r': [[0, 1, 1], [1, 1, 0]],
    'z3v': [[0, 1], [1, 1], [1, 0]], 'z3v_r': [[1, 0], [1, 1], [0, 1]],
    
    // --- L ÂûãÂàÜÈ°û ---
    // Â∞è L (3Ê†º)
    'L2': [[1,0],[1,1]], 'L2_r': [[1,1],[1,0]], 'L2_m': [[1,1],[0,1]], 'L2_mr': [[0,1],[1,1]],
    
    // ‰∏≠ L (4Ê†º)
    'L3_2': [[1,0],[1,0],[1,1]],      'L3_2_inv': [[1,1],[1,0],[1,0]], 
    'L3_2_r': [[1,1,1],[1,0,0]],      'L3_2_r_inv': [[0,0,1],[1,1,1]],
    'J3_2': [[0,1],[0,1],[1,1]],      'J3_2_inv': [[1,1],[0,1],[0,1]],
    'J3_2_r': [[1,1,1],[0,0,1]],      'J3_2_r_inv': [[1,0,0],[1,1,1]],

    // Â§ß L (5Ê†º)
    'L3': [[1,0,0],[1,0,0],[1,1,1]],  'L3_m': [[1,1,1],[0,0,1],[0,0,1]],
    'L3_r': [[1,1,1],[1,0,0],[1,0,0]],'L3_mr': [[0,0,1],[0,0,1],[1,1,1]],
    'J3': [[0,0,1],[0,0,1],[1,1,1]],  'J3_r': [[1,1,1],[0,0,1],[0,0,1]] 
};

const CATEGORIES = [
    { title: "Âü∫Êú¨ (Èªû„ÄÅÊñú„ÄÅÁ∑ö)", list: ['1', 'd2', 'd2_r', 'd3', 'd3_r', '2h', '3h', '4h', '5h', '2v', '3v', '4v', '5v'] },
    { title: "ÊñπÂ°ä & TÂûã & ZÂûã", list: ['2x2', '2x3', '3x2', '3x3', 'T3', 'T3_r', 'T3_m', 'T3_mr', 'z3', 'z3_r', 'z3v', 'z3v_r'] },
    { title: "Â∞è L (3Ê†º)", list: ['L2', 'L2_r', 'L2_m', 'L2_mr'] },
    { title: "‰∏≠ L (4Ê†º)", list: ['L3_2', 'J3_2', 'L3_2_inv', 'J3_2_inv', 'L3_2_r', 'J3_2_r', 'L3_2_r_inv', 'J3_2_r_inv'] },
    { title: "Â§ß L (5Ê†º)", list: ['L3', 'L3_r', 'L3_m', 'L3_mr', 'J3', 'J3_r'] }
];

function getColor(name) {
    if (name === '1') return '#F1C40F'; 
    
    // ‚òÖ‚òÖ‚òÖ ÂÑ™ÂÖàÂà§Êñ∑ L Âûã (Fix for inv issue) ‚òÖ‚òÖ‚òÖ
    if (name.startsWith('L2')) return '#FF80AB'; // Á≤âÁ¥Ö (Â∞èL)
    if (name.includes('3_2')) return '#9B59B6'; // Á¥´Ëâ≤ (‰∏≠L)
    if (name === 'L3' || name.startsWith('L3_') || name.startsWith('J3')) return '#5C6BC0'; // Ê∑±ÈùõËâ≤ (Â§ßL)

    // ÂÖ∂‰ªñÂΩ¢ÁãÄ
    if (name.startsWith('d')) return '#1ABC9C'; 
    if (name.includes('h') || (name.includes('v') && !name.includes('z'))) return '#3498DB'; // Ëóç (Áõ¥Á∑ö)
    if (name.includes('x')) return '#E74C3C'; 
    if (name.startsWith('T')) return '#2ECC71'; 
    if (name.startsWith('z')) return '#E67E22'; 
    
    return '#95A5A6';
}

// ==========================================
// Á®ãÂºèÈÇèËºØ
// ==========================================
let board = Array(8).fill().map(() => Array(8).fill(0));
let boardHistory = [];
let hand = [];
let solutionSteps = [];
let currentStepIdx = 0;
let isDragging = false;
let paintMode = 1; 

const boardEl = document.getElementById('board');
const boardWrapper = document.getElementById('boardWrapper'); 
const handEl = document.getElementById('hand');
const libContentEl = document.getElementById('libContent');
const modalEl = document.getElementById('libModal');
const statusEl = document.getElementById('status');
const btnNext = document.getElementById('btnNext');

function init() {
    renderBoard();
    renderLibraryMenu(); 
    document.addEventListener('mouseup', () => isDragging = false);
    document.addEventListener('touchend', () => isDragging = false);
}

function renderBoard() {
    boardEl.innerHTML = '';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (board[r][c] === 1) cell.classList.add('filled');
            
            cell.dataset.r = r;
            cell.dataset.c = c;
            
            cell.addEventListener('mousedown', onPointerDown);
            cell.addEventListener('mouseenter', onPointerEnter);
            cell.addEventListener('touchstart', onPointerDown, {passive: false});
            
            boardEl.appendChild(cell);
        }
    }
    boardEl.addEventListener('touchmove', onTouchMove, {passive: false});
}

function renderLibraryMenu() {
    libContentEl.innerHTML = '';
    CATEGORIES.forEach(cat => {
        const title = document.createElement('div');
        title.className = 'category-title';
        title.innerText = cat.title;
        libContentEl.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'lib-grid';
        
        cat.list.forEach(name => {
            if (!SHAPES[name]) return;
            const div = document.createElement('div');
            div.className = 'lib-piece';
            div.onclick = () => { addToHand(name); toggleLibrary(); }; 
            
            const canvas = drawShapeCanvas(SHAPES[name], 8, getColor(name));
            div.appendChild(canvas);
            grid.appendChild(div);
        });
        libContentEl.appendChild(grid);
    });
}

function renderHand() {
    handEl.innerHTML = '';
    if (hand.length === 0) {
        handEl.innerHTML = '<span style="color: #777; font-size: 0.9rem;">(Á©∫)</span>';
        return;
    }
    hand.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'hand-piece';
        div.onclick = () => removeFromHand(idx);
        
        const canvas = drawShapeCanvas(item.shape, 10, getColor(item.name));
        div.appendChild(canvas);
        
        const removeBtn = document.createElement('div');
        removeBtn.className = 'remove-btn';
        removeBtn.innerText = 'x';
        div.appendChild(removeBtn);
        
        handEl.appendChild(div);
    });
}

function drawShapeCanvas(shape, cellSize, color) {
    const canvas = document.createElement('canvas');
    const rows = shape.length;
    const cols = shape[0].length;
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = color;
    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            if(shape[r][c]) {
                ctx.fillRect(c*cellSize, r*cellSize, cellSize-1, cellSize-1);
            }
        }
    }
    return canvas;
}

function toggleLibrary() {
    modalEl.classList.toggle('show');
}

function lockBoard(locked) {
    if (locked) boardWrapper.classList.add('locked');
    else boardWrapper.classList.remove('locked');
}

function saveState() {
    boardHistory.push(JSON.parse(JSON.stringify(board)));
    if(boardHistory.length > 20) boardHistory.shift();
}

function updateCell(r, c) {
    if (board[r][c] !== paintMode) {
        board[r][c] = paintMode;
        const idx = r * 8 + c;
        const cell = boardEl.children[idx];
        if (paintMode === 1) cell.classList.add('filled');
        else cell.classList.remove('filled');
        resetSolution();
    }
}

function onPointerDown(e) {
    if (solutionSteps.length > 0) return; // ÈéñÂÆö‰∏≠

    if (e.type === 'touchstart' && e.touches.length > 1) return;
    if (e.cancelable) e.preventDefault();
    isDragging = true;
    const r = parseInt(this.dataset.r);
    const c = parseInt(this.dataset.c);
    
    saveState();
    paintMode = 1 - board[r][c];
    updateCell(r, c);
}

function onPointerEnter(e) {
    if (solutionSteps.length > 0) return; 
    if (isDragging) {
        const r = parseInt(this.dataset.r);
        const c = parseInt(this.dataset.c);
        updateCell(r, c);
    }
}

function onTouchMove(e) {
    if (solutionSteps.length > 0) return; 
    if (!isDragging) return;
    if (e.cancelable) e.preventDefault();

    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (target && target.classList.contains('cell')) {
        const r = parseInt(target.dataset.r);
        const c = parseInt(target.dataset.c);
        updateCell(r, c);
    }
}

function clearBoard() {
    saveState();
    board = Array(8).fill().map(() => Array(8).fill(0));
    renderBoard();
    resetSolution();
    lockBoard(false); 
}

function undoBoard() {
    if (boardHistory.length > 0) {
        board = boardHistory.pop();
        renderBoard();
        resetSolution();
        lockBoard(false); 
    }
}

function addToHand(name) {
    if (hand.length >= 3) return;
    hand.push({ name: name, shape: SHAPES[name] });
    renderHand();
    resetSolution();
}

function removeFromHand(idx) {
    hand.splice(idx, 1);
    renderHand();
    resetSolution();
}

function resetSolution() {
    solutionSteps = [];
    currentStepIdx = 0;
    statusEl.innerText = '';
    btnNext.disabled = true;
    btnNext.innerText = "Âü∑Ë°åÈÄô‰∏ÄÊ≠• ‚ñ∂";
    const previews = document.querySelectorAll('.cell.preview');
    previews.forEach(el => {
        el.classList.remove('preview');
        el.innerText = '';
    });
    lockBoard(false); 
}

function solve(currentBoard, pieces) {
    let bestSol = null;
    let maxCleared = -1;

    function* permutations(arr) {
        if (arr.length <= 1) yield arr;
        else {
            for (let i = 0; i < arr.length; i++) {
                const rest = arr.slice(0, i).concat(arr.slice(i + 1));
                for (const p of permutations(rest)) {
                    yield [arr[i], ...p];
                }
            }
        }
    }

    function canPlace(b, piece, r, c) {
        const rows = piece.length;
        const cols = piece[0].length;
        if (r + rows > 8 || c + cols > 8) return false;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (piece[i][j] === 1 && b[r + i][c + j] === 1) return false;
            }
        }
        return true;
    }

    function placeAndClear(b, piece, r, c) {
        let newB = b.map(row => [...row]);
        const rows = piece.length;
        const cols = piece[0].length;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (piece[i][j]) newB[r + i][c + j] = 1;
            }
        }
        let clearR = [], clearC = [];
        for(let i=0; i<8; i++) if(newB[i].every(v=>v===1)) clearR.push(i);
        for(let j=0; j<8; j++) if(newB.every(row=>row[j]===1)) clearC.push(j);
        
        let cleared = clearR.length + clearC.length;
        if (cleared > 0) {
            for(let row of clearR) for(let j=0; j<8; j++) newB[row][j] = 0;
            for(let col of clearC) for(let i=0; i<8; i++) newB[i][col] = 0;
        }
        return { board: newB, cleared: cleared };
    }

    function backtrack(b, remainingPieces, path, totalCleared) {
        if (remainingPieces.length === 0) {
            if (totalCleared > maxCleared) {
                maxCleared = totalCleared;
                bestSol = [...path];
            }
            return;
        }
        if (bestSol && maxCleared >= 5) return; 

        const current = remainingPieces[0];
        const rest = remainingPieces.slice(1);
        const shape = current.shape;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (canPlace(b, shape, r, c)) {
                    const res = placeAndClear(b, shape, r, c);
                    path.push({ name: current.name, r, c, cleared: res.cleared, shape });
                    backtrack(res.board, rest, path, totalCleared + res.cleared);
                    path.pop();
                    if (bestSol) return; 
                }
            }
        }
    }

    const perms = permutations(pieces);
    for (const p of perms) {
        backtrack(currentBoard, p, [], 0);
        if (bestSol) break; 
    }
    return bestSol;
}

function runSolver() {
    if (hand.length === 0) {
        statusEl.innerText = "Ë´ãÂÖàÈÅ∏ÊìáÊñπÂ°äÔºÅ";
        return;
    }
    statusEl.innerText = "Ë®àÁÆó‰∏≠...";
    setTimeout(() => {
        const sol = solve(board, hand);
        if (sol) {
            solutionSteps = sol;
            currentStepIdx = 0;
            previewStep();
        } else {
            statusEl.innerText = "‚ùå ÁÑ°Ëß£ÔºÅ";
        }
    }, 50);
}

function previewStep() {
    if (currentStepIdx >= solutionSteps.length) {
        statusEl.innerText = "üéâ ÂÆåÊàêÔºÅ";
        statusEl.style.color = "#2ECC71";
        btnNext.disabled = true;
        btnNext.innerText = "ÂÆåÊàê";
        hand = []; 
        renderHand();
        document.querySelectorAll('.cell.preview').forEach(el => {
            el.classList.remove('preview');
            el.innerText = '';
        });
        lockBoard(false); 
        return;
    }

    lockBoard(true); // ÈéñÂÆö

    const step = solutionSteps[currentStepIdx];
    statusEl.innerText = `Ê≠•È©ü ${currentStepIdx + 1}: Ê∂à ${step.cleared} Ë°å`;
    statusEl.style.color = "#F1C40F";
    btnNext.disabled = false;
    btnNext.innerText = "Âü∑Ë°åÈÄô‰∏ÄÊ≠• ‚ñ∂";

    const cells = document.querySelectorAll('.cell');
    cells.forEach(c => {
        c.classList.remove('preview');
        c.innerText = '';
    });

    const shape = step.shape;
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if (shape[i][j]) {
                const idx = (step.r + i) * 8 + (step.c + j);
                if (cells[idx]) {
                    cells[idx].classList.add('preview');
                    cells[idx].innerText = currentStepIdx + 1;
                }
            }
        }
    }
}

function applyNextStep() {
    if (currentStepIdx >= solutionSteps.length) return;
    const step = solutionSteps[currentStepIdx];
    saveState();

    for(let i=0; i<step.shape.length; i++) {
        for(let j=0; j<step.shape[0].length; j++) {
            if (step.shape[i][j]) board[step.r + i][step.c + j] = 1;
        }
    }
    let clearR = [], clearC = [];
    for(let i=0; i<8; i++) if(board[i].every(v=>v===1)) clearR.push(i);
    for(let j=0; j<8; j++) if(board.every(row=>row[j]===1)) clearC.push(j);
    
    if (clearR.length > 0 || clearC.length > 0) {
        for(let row of clearR) for(let j=0; j<8; j++) board[row][j] = 0;
        for(let col of clearC) for(let i=0; i<8; i++) board[i][col] = 0;
    }
    renderBoard();
    currentStepIdx++;
    previewStep();
}

init();
</script>
</body>
</html>