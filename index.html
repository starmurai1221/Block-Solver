<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast Solver Ultimate</title>
    <style>
        :root {
            --bg-color: #2C3E50;
            --board-bg: #34495E;
            --cell-empty: #ECF0F1;
            --cell-filled: #7F8C8D;
            --text-color: white;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            /* é˜²æ­¢ä¸‹æ‹‰é‡æ•´å¹²æ“¾æ“ä½œ */
            overscroll-behavior: none; 
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-align: center; }
        
        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* é›»è…¦ç‰ˆæœ€å¤§å¯¬åº¦ */
            align-items: center;
            gap: 15px;
        }

        /* --- 1. æ£‹ç›¤å€ (æ‰‹æ©Ÿå¼·åˆ¶å¯¬åº¦ä¿®å¾©) --- */
        .board-wrapper {
            /* é—œéµä¿®æ­£ï¼šç›´æ¥è¨­å®šå¯¬åº¦ç‚ºè¢å¹•çš„ 95%ï¼Œä¿è­‰æ‰‹æ©Ÿçœ‹å¾—åˆ° */
            width: 95vw; 
            max-width: 500px; /* é›»è…¦ç‰ˆé™åˆ¶ */
            background-color: var(--board-bg);
            border-radius: 8px;
            padding: 5px;
            /* å¼·åˆ¶ä¿æŒæ­£æ–¹å½¢ */
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .board-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1rem;
            color: white;
            user-select: none;
        }

        .cell.filled { background-color: var(--cell-filled); }
        /* é è¦½é¡è‰²æ”¹ç‚ºäº®ç¶ è‰²ï¼Œæ›´æ˜é¡¯ */
        .cell.preview { background-color: #00E676 !important; color: #000; } 

        .controls {
            width: 95vw;
            max-width: 500px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            border: none;
            padding: 12px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.96); }
        .btn-undo { background-color: #95A5A6; color: white; }
        .btn-clear { background-color: #E74C3C; color: white; }
        
        .btn-solve { 
            background-color: #27AE60; color: white; 
            width: 100%; margin: 10px 0; font-size: 1.2rem; padding: 15px;
        }
        .btn-next { background-color: #F39C12; color: white; width: 100%; padding: 15px;}
        .btn-next:disabled { background-color: #555; opacity: 0.5; }

        /* --- 2. æ–¹å¡Šå€ --- */
        .right-panel {
            width: 95vw;
            max-width: 500px;
            display: flex;
            flex-direction: column;
        }

        .panel-label { margin-bottom: 5px; font-size: 0.9rem; color: #BDC3C7; }

        /* æœ¬è¼ªæ‰‹ç‰Œ */
        .hand-area {
            background-color: var(--board-bg);
            height: 80px;
            border-radius: 8px;
            padding: 5px 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-start;
            overflow-x: auto; /* å…è¨±æ©«å‘æ²å‹• */
            margin-bottom: 10px;
            white-space: nowrap;
        }

        .hand-piece {
            position: relative;
            background: rgba(0,0,0,0.2);
            padding: 4px;
            border-radius: 4px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hand-piece .remove-btn {
            position: absolute;
            top: -5px; right: -5px;
            background: #E74C3C; color: white;
            border-radius: 50%;
            width: 18px; height: 18px;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
            font-weight: bold;
        }

        /* æ–¹å¡Šåº« */
        .library-area {
            background-color: var(--board-bg);
            border-radius: 8px;
            padding: 8px;
            max-height: 40vh; /* é™åˆ¶é«˜åº¦ */
            overflow-y: auto; 
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(55px, 1fr)); /* è‡ªå‹•æ’ç‰ˆ */
            gap: 8px;
        }

        .lib-piece {
            aspect-ratio: 1;
            background-color: rgba(255,255,255,0.05);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .lib-piece:active { background-color: rgba(255,255,255,0.2); }
        
        .lib-piece canvas {
            max-width: 90%;
            max-height: 90%;
        }

        .status-msg {
            text-align: center;
            margin: 5px 0;
            min-height: 20px;
            color: #F1C40F;
            font-weight: bold;
        }

    </style>
</head>
<body>

    <h1>Block Blast Solver</h1>

    <div class="container">
        <div class="board-wrapper">
            <div id="board" class="board-container">
                </div>
        </div>
        
        <div class="controls">
            <button class="btn-undo" onclick="undoBoard()">â†º ä¸Šä¸€æ­¥</button>
            <button class="btn-clear" onclick="clearBoard()">ğŸ—‘ æ¸…ç©º</button>
        </div>

        <div class="right-panel">
            
            <button class="btn-solve" onclick="runSolver()">âœ¨ è¨ˆç®—æœ€ä½³è§£ âœ¨</button>
            <div id="status" class="status-msg"></div>
            <button id="btnNext" class="btn-next" onclick="applyNextStep()" disabled>åŸ·è¡Œé€™ä¸€æ­¥ â–¶</button>

            <div class="panel-label" style="margin-top: 15px;">æœ¬è¼ªæ–¹å¡Š (é»æ“Š x åˆªé™¤)</div>
            <div id="hand" class="hand-area"></div>

            <div class="panel-label">æ–¹å¡Šåº« (é»æ“ŠåŠ å…¥)</div>
            <div id="library" class="library-area">
                </div>
        </div>
    </div>

<script>
// ==========================================
// 1. è³‡æ–™å®šç¾© (åŒ…å«æ–°å¢æ–¹å¡Š)
// ==========================================
const SHAPES = {
    // é»
    '1': [[1]],
    
    // æ–œè§’
    'd2': [[1,0],[0,1]], 'd2_r': [[0,1],[1,0]],
    'd3': [[1, 0, 0], [0, 1, 0], [0, 0, 1]], 'd3_r': [[0, 0, 1], [0, 1, 0], [1, 0, 0]],

    // ç›´ç·š
    '2h': [[1,1]], '3h': [[1,1,1]], '4h': [[1,1,1,1]], '5h': [[1,1,1,1,1]],
    '2v': [[1],[1]], '3v': [[1],[1],[1]], '4v': [[1],[1],[1],[1]], '5v': [[1],[1],[1],[1],[1]],

    // æ–¹å¡Š
    '2x2': [[1,1],[1,1]], '2x3': [[1,1,1],[1,1,1]], '3x2': [[1,1],[1,1],[1,1]], '3x3': [[1,1,1],[1,1,1],[1,1,1]],

    // Tå‹
    'T3': [[1,1,1],[0,1,0]], 'T3_r': [[0,1],[1,1],[0,1]],
    'T3_m': [[0,1,0],[1,1,1]], 'T3_mr': [[1,0],[1,1],[1,0]],

    // Zå‹ (æ–°å¢)
    'z3': [[1, 1, 0], [0, 1, 1]], 'z3_r': [[0, 1, 1], [1, 1, 0]],
    'z3v': [[0, 1], [1, 1], [1, 0]], 'z3v_r': [[1, 0], [1, 1], [0, 1]],

    // å° L
    'L2': [[1,0],[1,1]], 'L2_r': [[1,1],[1,0]], 'L2_m': [[1,1],[0,1]], 'L2_mr': [[0,1],[1,1]],
    
    // ä¸­ L
    'L3_2': [[1,0],[1,0],[1,1]], 'J3_2': [[0,1],[0,1],[1,1]],
    'L3_2_inv': [[1,1],[1,0],[1,0]], 'J3_2_inv': [[1,1],[0,1],[0,1]],
    'L3_2_r': [[1,1,1],[1,0,0]], 'J3_2_r': [[1,1,1],[0,0,1]],
    'L3_2_r_inv': [[0,0,1],[1,1,1]], 'J3_2_r_inv': [[1,0,0],[1,1,1]],
    
    // å¤§ L
    'L3': [[1,0,0],[1,0,0],[1,1,1]], 'L3_r': [[1,1,1],[1,0,0],[1,0,0]],
    'L3_m': [[1,1,1],[0,0,1],[0,0,1]], 'L3_mr': [[0,0,1],[0,0,1],[1,1,1]],
    'J3': [[0,0,1],[0,0,1],[1,1,1]], 'J3_r': [[1,1,1],[0,0,1],[0,0,1]]
};

// 2. æ’åºå®šç¾© (é»-æ–œ-ç·š-æ–¹-T-Z-L)
const SHAPE_ORDER = [
    '1', // é»
    'd2', 'd2_r', 'd3', 'd3_r', // æ–œè§’
    '2h', '3h', '4h', '5h', // æ©«ç·š
    '2v', '3v', '4v', '5v', // ç›´ç·š
    '2x2', '2x3', '3x2', '3x3', // æ–¹å¡Š
    'T3', 'T3_r', 'T3_m', 'T3_mr', // Tå‹
    'z3', 'z3_r', 'z3v', 'z3v_r', // Zå‹
    'L2', 'L2_r', 'L2_m', 'L2_mr', // å°L
    'L3_2', 'J3_2', 'L3_2_inv', 'J3_2_inv', 'L3_2_r', 'J3_2_r', 'L3_2_r_inv', 'J3_2_r_inv', // ä¸­L
    'L3', 'L3_r', 'L3_m', 'L3_mr', 'J3', 'J3_r' // å¤§L
];

// 3. é¡è‰²å®šç¾© (åŒçµ„åŒè‰²)
function getColor(name) {
    if (name === '1') return '#F1C40F'; // é»ƒ (é»)
    if (name.startsWith('d')) return '#1ABC9C'; // é’ (æ–œè§’)
    if (name.includes('h') || name.includes('v') && !name.includes('z')) return '#3498DB'; // è— (ç›´ç·š)
    if (name.includes('x')) return '#E74C3C'; // ç´… (æ–¹å¡Š)
    if (name.startsWith('T')) return '#2ECC71'; // ç¶  (Tå‹)
    if (name.startsWith('z')) return '#E67E22'; // æ©˜ (Zå‹)
    if (name.includes('L') || name.includes('J')) return '#9B59B6'; // ç´« (Lå‹)
    return '#95A5A6'; // é è¨­ç°
}

// ==========================================
// ç¨‹å¼é‚è¼¯ (ä¿®æ­£ç‰ˆ)
// ==========================================
let board = Array(8).fill().map(() => Array(8).fill(0));
let boardHistory = [];
let hand = [];
let solutionSteps = [];
let currentStepIdx = 0;
let isDragging = false;
let paintMode = 1; 

const boardEl = document.getElementById('board');
const handEl = document.getElementById('hand');
const libEl = document.getElementById('library');
const statusEl = document.getElementById('status');
const btnNext = document.getElementById('btnNext');

function init() {
    renderBoard();
    renderLibrary();
    
    document.addEventListener('mouseup', () => isDragging = false);
    document.addEventListener('touchend', () => isDragging = false);
}

function renderBoard() {
    boardEl.innerHTML = '';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (board[r][c] === 1) cell.classList.add('filled');
            
            cell.dataset.r = r;
            cell.dataset.c = c;
            
            // æ»‘é¼ 
            cell.addEventListener('mousedown', onPointerDown);
            cell.addEventListener('mouseenter', onPointerEnter);
            // è§¸æ§
            cell.addEventListener('touchstart', onPointerDown, {passive: false});
            
            boardEl.appendChild(cell);
        }
    }
    // ç¶å®šç§»å‹•äº‹ä»¶åœ¨ç›¤é¢ä¸Š
    boardEl.addEventListener('touchmove', onTouchMove, {passive: false});
}

function renderLibrary() {
    libEl.innerHTML = '';
    // ä¾ç…§æŒ‡å®šçš„ SHAPE_ORDER æ¸²æŸ“
    SHAPE_ORDER.forEach(name => {
        if (!SHAPES[name]) return;
        const shape = SHAPES[name];
        
        const div = document.createElement('div');
        div.className = 'lib-piece';
        div.onclick = () => addToHand(name);
        
        const canvas = drawShapeCanvas(shape, 8, getColor(name));
        div.appendChild(canvas);
        libEl.appendChild(div);
    });
}

function renderHand() {
    handEl.innerHTML = '';
    hand.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'hand-piece';
        div.onclick = () => removeFromHand(idx);
        
        // æ‰‹ç‰Œ Canvas ç¨å¤§
        const canvas = drawShapeCanvas(item.shape, 10, getColor(item.name));
        div.appendChild(canvas);
        
        const removeBtn = document.createElement('div');
        removeBtn.className = 'remove-btn';
        removeBtn.innerText = 'x';
        div.appendChild(removeBtn);
        
        handEl.appendChild(div);
    });
}

function drawShapeCanvas(shape, cellSize, color) {
    const canvas = document.createElement('canvas');
    const rows = shape.length;
    const cols = shape[0].length;
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = color;
    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            if(shape[r][c]) {
                ctx.fillRect(c*cellSize, r*cellSize, cellSize-1, cellSize-1);
            }
        }
    }
    return canvas;
}

// --- äº’å‹• ---
function saveState() {
    boardHistory.push(JSON.parse(JSON.stringify(board)));
    if(boardHistory.length > 20) boardHistory.shift();
}

function updateCell(r, c) {
    if (board[r][c] !== paintMode) {
        board[r][c] = paintMode;
        const idx = r * 8 + c;
        const cell = boardEl.children[idx];
        if (paintMode === 1) cell.classList.add('filled');
        else cell.classList.remove('filled');
        resetSolution();
    }
}

function onPointerDown(e) {
    if (e.type === 'touchstart' && e.touches.length > 1) return;
    if (e.cancelable) e.preventDefault();
    isDragging = true;
    const r = parseInt(this.dataset.r);
    const c = parseInt(this.dataset.c);
    
    saveState();
    paintMode = 1 - board[r][c];
    updateCell(r, c);
}

function onPointerEnter(e) {
    if (isDragging) {
        const r = parseInt(this.dataset.r);
        const c = parseInt(this.dataset.c);
        updateCell(r, c);
    }
}

function onTouchMove(e) {
    if (!isDragging) return;
    if (e.cancelable) e.preventDefault();

    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (target && target.classList.contains('cell')) {
        const r = parseInt(target.dataset.r);
        const c = parseInt(target.dataset.c);
        updateCell(r, c);
    }
}

function clearBoard() {
    saveState();
    board = Array(8).fill().map(() => Array(8).fill(0));
    renderBoard();
    resetSolution();
}

function undoBoard() {
    if (boardHistory.length > 0) {
        board = boardHistory.pop();
        renderBoard(); // é‡ç¹ªæœ€ä¿éšª
        resetSolution();
    }
}

function addToHand(name) {
    if (hand.length >= 3) return;
    hand.push({ name: name, shape: SHAPES[name] });
    renderHand();
    resetSolution();
}

function removeFromHand(idx) {
    hand.splice(idx, 1);
    renderHand();
    resetSolution();
}

// --- ç®—æ³• ---
function resetSolution() {
    solutionSteps = [];
    currentStepIdx = 0;
    statusEl.innerText = '';
    btnNext.disabled = true;
    btnNext.innerText = "åŸ·è¡Œé€™ä¸€æ­¥ â–¶";
    // æ¸…é™¤é è¦½æ¨£å¼
    const previews = document.querySelectorAll('.cell.preview');
    previews.forEach(el => {
        el.classList.remove('preview');
        el.innerText = '';
    });
}

function solve(currentBoard, pieces) {
    let bestSol = null;
    let maxCleared = -1;

    function* permutations(arr) {
        if (arr.length <= 1) yield arr;
        else {
            for (let i = 0; i < arr.length; i++) {
                const rest = arr.slice(0, i).concat(arr.slice(i + 1));
                for (const p of permutations(rest)) {
                    yield [arr[i], ...p];
                }
            }
        }
    }

    function canPlace(b, piece, r, c) {
        const rows = piece.length;
        const cols = piece[0].length;
        if (r + rows > 8 || c + cols > 8) return false;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (piece[i][j] === 1 && b[r + i][c + j] === 1) return false;
            }
        }
        return true;
    }

    function placeAndClear(b, piece, r, c) {
        let newB = b.map(row => [...row]);
        const rows = piece.length;
        const cols = piece[0].length;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (piece[i][j]) newB[r + i][c + j] = 1;
            }
        }
        let clearR = [], clearC = [];
        for(let i=0; i<8; i++) if(newB[i].every(v=>v===1)) clearR.push(i);
        for(let j=0; j<8; j++) if(newB.every(row=>row[j]===1)) clearC.push(j);
        
        let cleared = clearR.length + clearC.length;
        if (cleared > 0) {
            for(let row of clearR) for(let j=0; j<8; j++) newB[row][j] = 0;
            for(let col of clearC) for(let i=0; i<8; i++) newB[i][col] = 0;
        }
        return { board: newB, cleared: cleared };
    }

    function backtrack(b, remainingPieces, path, totalCleared) {
        if (remainingPieces.length === 0) {
            if (totalCleared > maxCleared) {
                maxCleared = totalCleared;
                bestSol = [...path];
            }
            return;
        }
        if (bestSol && maxCleared >= 5) return; 

        const current = remainingPieces[0];
        const rest = remainingPieces.slice(1);
        const shape = current.shape;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (canPlace(b, shape, r, c)) {
                    const res = placeAndClear(b, shape, r, c);
                    path.push({ name: current.name, r, c, cleared: res.cleared, shape });
                    backtrack(res.board, rest, path, totalCleared + res.cleared);
                    path.pop();
                    if (bestSol) return; 
                }
            }
        }
    }

    const perms = permutations(pieces);
    for (const p of perms) {
        backtrack(currentBoard, p, [], 0);
        if (bestSol) break; 
    }
    return bestSol;
}

function runSolver() {
    if (hand.length === 0) {
        statusEl.innerText = "è«‹å…ˆé¸æ“‡æ–¹å¡Šï¼";
        return;
    }
    statusEl.innerText = "è¨ˆç®—ä¸­...";
    setTimeout(() => {
        const sol = solve(board, hand);
        if (sol) {
            solutionSteps = sol;
            currentStepIdx = 0;
            previewStep();
        } else {
            statusEl.innerText = "âŒ ç„¡è§£ï¼";
        }
    }, 50);
}

function previewStep() {
    if (currentStepIdx >= solutionSteps.length) {
        statusEl.innerText = "ğŸ‰ å®Œæˆï¼";
        statusEl.style.color = "#2ECC71";
        btnNext.disabled = true;
        btnNext.innerText = "å®Œæˆ";
        hand = []; 
        renderHand();
        document.querySelectorAll('.cell.preview').forEach(el => {
            el.classList.remove('preview');
            el.innerText = '';
        });
        return;
    }

    const step = solutionSteps[currentStepIdx];
    statusEl.innerText = `æ­¥é©Ÿ ${currentStepIdx + 1}: æ¶ˆ ${step.cleared} è¡Œ`;
    statusEl.style.color = "#F1C40F";
    btnNext.disabled = false;
    btnNext.innerText = "åŸ·è¡Œé€™ä¸€æ­¥ â–¶";

    const cells = document.querySelectorAll('.cell');
    cells.forEach(c => {
        c.classList.remove('preview');
        c.innerText = '';
    });

    const shape = step.shape;
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if (shape[i][j]) {
                const idx = (step.r + i) * 8 + (step.c + j);
                if (cells[idx]) {
                    cells[idx].classList.add('preview');
                    cells[idx].innerText = currentStepIdx + 1;
                }
            }
        }
    }
}

function applyNextStep() {
    if (currentStepIdx >= solutionSteps.length) return;
    const step = solutionSteps[currentStepIdx];
    saveState();

    // æ›´æ–°è³‡æ–™
    for(let i=0; i<step.shape.length; i++) {
        for(let j=0; j<step.shape[0].length; j++) {
            if (step.shape[i][j]) board[step.r + i][step.c + j] = 1;
        }
    }
    let clearR = [], clearC = [];
    for(let i=0; i<8; i++) if(board[i].every(v=>v===1)) clearR.push(i);
    for(let j=0; j<8; j++) if(board.every(row=>row[j]===1)) clearC.push(j);
    
    if (clearR.length > 0 || clearC.length > 0) {
        for(let row of clearR) for(let j=0; j<8; j++) board[row][j] = 0;
        for(let col of clearC) for(let i=0; i<8; i++) board[i][col] = 0;
    }
    renderBoard();
    currentStepIdx++;
    previewStep();
}

init();
</script>
</body>
</html>
