<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast Solver v5.0</title>
    <style>
        :root {
            --bg-color: #2C3E50;
            --board-bg: #34495E;
            --cell-empty: #ECF0F1;
            --cell-filled: #7F8C8D;
            --cell-new: #3498DB;
            --cell-preview: #2ECC71;
            --modal-bg: rgba(44, 62, 80, 0.98);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        /* --- æ ¸å¿ƒä¿®æ”¹ï¼šé–æ­»è¦–çª— --- */
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden; /* ç¦æ­¢æ²å‹• */
            position: fixed; /* é–å®šä½ç½® */
            background-color: var(--bg-color);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            touch-action: none; /* å…¨åŸŸç¦æ­¢æ‰‹å‹¢ */
        }

        /* ä½¿ç”¨ Flexbox è®“å…§å®¹å‚ç›´æ’åˆ—ä¸¦è‡ªå‹•ç¸®æ”¾ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            max-width: 600px; /* é›»è…¦ç‰ˆé™åˆ¶å¯¬åº¦ */
            margin: 0 auto;
            padding: 10px;
        }

        /* æ¨™é¡Œå€ */
        .header {
            flex: 0 0 auto; /* å›ºå®šé«˜åº¦ */
            display: flex; align-items: center; justify-content: center;
            position: relative; margin-bottom: 10px;
            height: 40px;
        }
        h1 { margin: 0; font-size: 1.2rem; }
        .menu-btn {
            position: absolute; left: 0;
            background: #3498DB; color: white; border: none;
            padding: 8px 12px; border-radius: 6px; font-size: 1rem;
        }

        /* æ£‹ç›¤å€ (è‡ªå‹•ä¼¸ç¸®) */
        .board-section {
            flex: 1; /* ä½”æ“šå‰©é¤˜ç©ºé–“ */
            display: flex; justify-content: center; align-items: center;
            min-height: 0; /* å…è¨±ç¸®å° */
            margin-bottom: 10px;
        }

        .board-wrapper {
            background-color: var(--board-bg);
            border-radius: 8px; padding: 5px;
            /* é—œéµï¼šä¿æŒæ­£æ–¹å½¢ï¼Œä½†ä¸è¦è¶…éå¯¬åº¦æˆ–é«˜åº¦çš„é™åˆ¶ */
            width: min(90vw, 45vh); 
            height: min(90vw, 45vh);
            display: grid;
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            position: relative;
        }
        
        /* é–å®šé®ç½© */
        .board-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; display: none; 
        }
        .board-wrapper.locked .board-overlay { display: block; }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 2px;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 0.8rem; color: white;
            user-select: none;
        }
        .cell.filled { background-color: var(--cell-filled); }
        .cell.new { background-color: var(--cell-new) !important; }
        .cell.preview { background-color: var(--cell-preview) !important; color: #000; box-shadow: inset 0 0 0 2px #fff; }

        /* æ§åˆ¶å€ */
        .controls-section {
            flex: 0 0 auto; /* å›ºå®šé«˜åº¦ */
            display: flex; flex-direction: column; gap: 8px;
            padding-bottom: 10px; /* é ç•™åº•éƒ¨å®‰å…¨å€ */
        }

        .btn-row {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }

        button {
            border: none; padding: 12px; border-radius: 6px;
            font-size: 1rem; cursor: pointer; font-weight: bold;
        }
        button:active { transform: scale(0.96); }
        .btn-undo { background-color: #95A5A6; color: white; }
        .btn-clear { background-color: #E74C3C; color: white; }
        .btn-solve { background-color: #27AE60; color: white; width: 100%; font-size: 1.1rem; }
        .btn-next { background-color: #F39C12; color: white; width: 100%; }
        .btn-next:disabled { background-color: #555; opacity: 0.5; }

        .status-msg {
            text-align: center; height: 20px; font-size: 0.9rem;
            color: #F1C40F; font-weight: bold; overflow: hidden;
        }

        /* æ‰‹ç‰Œå€ */
        .hand-area {
            background-color: var(--board-bg);
            height: 70px; border-radius: 8px;
            padding: 5px; display: flex; gap: 10px;
            align-items: center; justify-content: center;
        }
        .hand-piece {
            position: relative;
            background: rgba(0,0,0,0.2);
            padding: 2px; border-radius: 4px;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
        }
        .hand-piece .remove-btn {
            position: absolute; top: -6px; right: -6px;
            background: #E74C3C; color: white; border-radius: 50%;
            width: 18px; height: 18px; font-size: 12px;
            line-height: 18px; text-align: center; font-weight: bold;
            border: 2px solid var(--board-bg);
        }
        .hand-piece canvas { max-height: 50px; }

        /* æ–¹å¡Šåº«é¸å–® (å”¯ä¸€å¯ä»¥æ²å‹•çš„åœ°æ–¹) */
        .library-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--modal-bg); z-index: 100;
            display: flex; flex-direction: column; align-items: center;
            padding: 20px;
            visibility: hidden; opacity: 0; transition: opacity 0.2s;
        }
        .library-modal.show { visibility: visible; opacity: 1; }

        .modal-header {
            width: 100%; max-width: 600px;
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; flex: 0 0 auto;
        }
        .close-btn { background: transparent; font-size: 2rem; color: white; padding: 0; }

        .library-content {
            flex: 1; width: 100%; max-width: 600px;
            overflow-y: auto; /* å…è¨±å…§éƒ¨æ²å‹• */
            -webkit-overflow-scrolling: touch; 
            padding-bottom: 40px;
        }

        .category-title {
            color: #BDC3C7; font-size: 0.9rem; margin: 15px 0 5px 0; border-bottom: 1px solid #555;
        }
        .lib-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(55px, 1fr)); gap: 12px;
        }
        .lib-piece {
            aspect-ratio: 1; background-color: rgba(255,255,255,0.1);
            border-radius: 8px; display: flex; justify-content: center; align-items: center;
        }
        .lib-piece.selected { border: 2px solid #2ECC71; background-color: rgba(46, 204, 113, 0.2); }
        .lib-piece .count-badge {
            position: absolute; top: -5px; right: -5px;
            background: #2ECC71; color: white; border-radius: 50%; width: 18px; height: 18px;
            font-size: 10px; line-height: 18px; text-align: center; display: none;
        }
        .lib-piece.selected .count-badge { display: block; }
        .lib-piece canvas { max-width: 80%; max-height: 80%; }

    </style>
</head>
<body>

<div class="app-container">
    <div class="header">
        <button class="menu-btn" onclick="openLibrary()">â˜° æ–¹å¡Šåº«</button>
        <h1>Block Blast Solver v5.0</h1>
    </div>

    <div class="board-section">
        <div id="boardWrapper" class="board-wrapper">
            <div class="board-overlay"></div>
            </div>
    </div>

    <div class="controls-section">
        <div class="btn-row">
            <button class="btn-undo" onclick="undoBoard()">â†º ä¸Šä¸€æ­¥</button>
            <button class="btn-clear" onclick="clearBoard()">ğŸ—‘ æ¸…ç©º</button>
        </div>

        <div id="status" class="status-msg"></div>

        <button class="btn-solve" onclick="runSolver()">âœ¨ è¨ˆç®—æœ€ä½³è§£ âœ¨</button>
        <button id="btnNext" class="btn-next" onclick="applyNextStep()" disabled>åŸ·è¡Œé€™ä¸€æ­¥ â–¶</button>
        
        <div style="text-align: center; font-size: 0.8rem; color: #aaa;">æœ¬è¼ªæ–¹å¡Š</div>
        <div id="hand" class="hand-area"><span style="color: #777;">(ç©º)</span></div>
    </div>
</div>

<div id="libModal" class="library-modal">
    <div class="modal-header">
        <h2 style="margin:0">é¸æ“‡æ–¹å¡Š (<span id="selCount">0</span>/3)</h2>
        <button class="close-btn" onclick="closeLibrary()">Ã—</button>
    </div>
    <div style="font-size: 0.8rem; color: #BDC3C7; margin-bottom: 10px;">é»æ“Šç´¯åŠ ï¼Œé•·æŒ‰å–æ¶ˆ</div>
    <div id="libContent" class="library-content"></div>
</div>

<script>
// ==================== ç¦æ­¢å…¨åŸŸæ²å‹• (iOS é—œéµ) ====================
document.body.addEventListener('touchmove', function(e) {
    // å¦‚æœè§¸æ§çš„ç›®æ¨™ä¸æ˜¯åœ¨ "library-content" (é¸å–®) è£¡é¢ï¼Œå°±ç¦æ­¢æ²å‹•
    if (!e.target.closest('.library-content')) {
        e.preventDefault();
    }
}, { passive: false });

// ==================== è³‡æ–™èˆ‡è¨­å®š ====================
const SHAPES = {
    '1': [[1]],
    '2h': [[1,1]], '3h': [[1,1,1]], '4h': [[1,1,1,1]], '5h': [[1,1,1,1,1]],
    '2v': [[1],[1]], '3v': [[1],[1],[1]], '4v': [[1],[1],[1],[1]], '5v': [[1],[1],[1],[1],[1]],
    'd2': [[1,0],[0,1]], 'd2_r': [[0,1],[1,0]],
    'd3': [[1,0,0],[0,1,0],[0,0,1]], 'd3_r': [[0,0,1],[0,1,0],[1,0,0]],
    '2x2': [[1,1],[1,1]], '2x3': [[1,1,1],[1,1,1]], '3x2': [[1,1],[1,1],[1,1]], '3x3': [[1,1,1],[1,1,1],[1,1,1]],
    'T3': [[1,1,1],[0,1,0]], 'T3_r': [[0,1],[1,1],[0,1]], 'T3_m': [[0,1,0],[1,1,1]], 'T3_mr': [[1,0],[1,1],[1,0]],
    'z3': [[1,1,0],[0,1,1]], 'z3_r': [[0,1,1],[1,1,0]], 'z3v': [[0,1],[1,1],[1,0]], 'z3v_r': [[1,0],[1,1],[0,1]],
    'L2': [[1,0],[1,1]], 'L2_r': [[1,1],[1,0]], 'L2_m': [[1,1],[0,1]], 'L2_mr': [[0,1],[1,1]],
    'L3_2': [[1,0],[1,0],[1,1]], 'L3_2_inv': [[1,1],[1,0],[1,0]], 
    'L3_2_r': [[1,1,1],[1,0,0]], 'L3_2_r_inv': [[0,0,1],[1,1,1]],
    'J3_2': [[0,1],[0,1],[1,1]], 'J3_2_inv': [[1,1],[0,1],[0,1]],
    'J3_2_r': [[1,1,1],[0,0,1]], 'J3_2_r_inv': [[1,0,0],[1,1,1]],
    'L3': [[1,0,0],[1,0,0],[1,1,1]], 'L3_m': [[1,1,1],[0,0,1],[0,0,1]],
    'L3_r': [[1,1,1],[1,0,0],[1,0,0]],'L3_mr': [[0,0,1],[0,0,1],[1,1,1]],
    'J3': [[0,0,1],[0,0,1],[1,1,1]], 'J3_r': [[1,1,1],[0,0,1],[0,0,1]]
};

const CATEGORIES = [
    { title: "åŸºæœ¬ (é»ã€æ–œã€ç·š)", list: ['1', 'd2', 'd2_r', 'd3', 'd3_r', '2h', '3h', '4h', '5h', '2v', '3v', '4v', '5v'] },
    { title: "æ–¹å¡Š & Tå‹ & Zå‹", list: ['2x2', '2x3', '3x2', '3x3', 'T3', 'T3_r', 'T3_m', 'T3_mr', 'z3', 'z3_r', 'z3v', 'z3v_r'] },
    { title: "å° L (3æ ¼)", list: ['L2', 'L2_r', 'L2_m', 'L2_mr'] },
    { title: "ä¸­ L (4æ ¼)", list: ['L3_2', 'J3_2', 'L3_2_inv', 'J3_2_inv', 'L3_2_r', 'J3_2_r', 'L3_2_r_inv', 'J3_2_r_inv'] },
    { title: "å¤§ L (5æ ¼)", list: ['L3', 'L3_r', 'L3_m', 'L3_mr', 'J3', 'J3_r'] }
];

function getColor(name) {
    if (name === '1') return '#F1C40F'; 
    if (name.startsWith('L2')) return '#FF80AB'; 
    if (name.includes('3_2')) return '#9B59B6'; 
    if (name === 'L3' || name.startsWith('L3_') || name.startsWith('J3')) return '#5C6BC0'; 
    if (name.startsWith('d')) return '#1ABC9C'; 
    if (name.includes('h') || (name.includes('v') && !name.includes('z'))) return '#3498DB'; 
    if (name.includes('x')) return '#E74C3C'; 
    if (name.startsWith('T')) return '#2ECC71'; 
    if (name.startsWith('z')) return '#E67E22'; 
    return '#95A5A6';
}

// ==================== ç¨‹å¼é‚è¼¯ ====================
let board = Array(8).fill().map(() => Array(8).fill(0));
let newlyPlacedCells = []; 
let boardHistory = [];
let hand = [];
let solutionSteps = [];
let currentStepIdx = 0;
let isDragging = false;
let paintMode = 1; 

const boardWrapper = document.getElementById('boardWrapper');
const handEl = document.getElementById('hand');
const libContentEl = document.getElementById('libContent');
const modalEl = document.getElementById('libModal');
const selCountEl = document.getElementById('selCount');
const statusEl = document.getElementById('status');
const btnNext = document.getElementById('btnNext');

function init() {
    renderBoard();
    renderLibraryMenu(); 
    // å…¨åŸŸæ»‘é¼ é‡‹æ”¾
    document.addEventListener('mouseup', () => isDragging = false);
    document.addEventListener('touchend', () => isDragging = false);
}

// ==================== ç¹ªåœ–é‚è¼¯ ====================
function renderBoard() {
    boardWrapper.innerHTML = '<div class="board-overlay"></div>'; // é‡ç½®
    
    // JSå‹•æ…‹ç”¢ç”Ÿ grid
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            
            if (board[r][c] === 1) {
                const isNew = newlyPlacedCells.some(p => p.r === r && p.c === c);
                if (isNew) cell.classList.add('new'); 
                else cell.classList.add('filled'); 
            }
            
            cell.dataset.r = r;
            cell.dataset.c = c;
            
            // ç¶å®šäº‹ä»¶
            cell.addEventListener('mousedown', onPointerDown);
            cell.addEventListener('mouseenter', onPointerEnter);
            cell.addEventListener('touchstart', onPointerDown, {passive: false});
            
            boardWrapper.appendChild(cell);
        }
    }
    // ç¶å®š touchmove åˆ° wrapper
    boardWrapper.addEventListener('touchmove', onTouchMove, {passive: false});
}

function renderLibraryMenu() {
    libContentEl.innerHTML = '';
    CATEGORIES.forEach(cat => {
        const title = document.createElement('div');
        title.className = 'category-title';
        title.innerText = cat.title;
        libContentEl.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'lib-grid';
        
        cat.list.forEach(name => {
            if (!SHAPES[name]) return;
            const div = document.createElement('div');
            div.className = 'lib-piece';
            div.dataset.name = name; 
            setupLibraryItemEvents(div, name);
            
            const badge = document.createElement('div');
            badge.className = 'count-badge';
            div.appendChild(badge);

            const canvas = drawShapeCanvas(SHAPES[name], 6, getColor(name));
            div.appendChild(canvas);
            grid.appendChild(div);
        });
        libContentEl.appendChild(grid);
    });
}

function setupLibraryItemEvents(element, name) {
    let pressTimer;
    let isLongPress = false;

    const startPress = (e) => {
        // å¤šé»ä¸è™•ç†
        if (e.type === 'touchstart' && e.touches.length > 1) return;
        
        isLongPress = false;
        pressTimer = setTimeout(() => {
            isLongPress = true;
            handleLongPress(name);
        }, 500);
    };

    const cancelPress = () => { if (pressTimer) clearTimeout(pressTimer); };

    const endPress = (e) => {
        if (pressTimer) clearTimeout(pressTimer);
        if (!isLongPress) {
            // å¦‚æœä¸æ˜¯é•·æŒ‰ï¼Œè¦–ç‚ºé»æ“Š
            if (e.type === 'touchend') e.preventDefault();
            addInstanceToHand(name);
        }
    };

    element.addEventListener('mousedown', startPress);
    element.addEventListener('mouseleave', cancelPress);
    element.addEventListener('mouseup', endPress);
    element.addEventListener('touchstart', startPress, {passive: false});
    element.addEventListener('touchmove', cancelPress);
    element.addEventListener('touchend', endPress);
}

function renderHand() {
    handEl.innerHTML = '';
    if (hand.length === 0) {
        handEl.innerHTML = '<span style="color: #777;">(ç©º)</span>';
        selCountEl.innerText = 0;
        return;
    }
    selCountEl.innerText = hand.length;
    hand.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'hand-piece';
        div.onclick = () => { removeFromHand(idx); }; 
        const canvas = drawShapeCanvas(item.shape, 8, getColor(item.name));
        div.appendChild(canvas);
        const removeBtn = document.createElement('div');
        removeBtn.className = 'remove-btn';
        removeBtn.innerText = 'x';
        div.appendChild(removeBtn);
        handEl.appendChild(div);
    });
}

function drawShapeCanvas(shape, cellSize, color) {
    const canvas = document.createElement('canvas');
    const rows = shape.length;
    const cols = shape[0].length;
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            if(shape[r][c]) ctx.fillRect(c*cellSize, r*cellSize, cellSize-1, cellSize-1);
        }
    }
    return canvas;
}

// ==================== äº’å‹•é‚è¼¯ ====================
function openLibrary() { updateLibraryUI(); modalEl.classList.add('show'); }
function closeLibrary() { modalEl.classList.remove('show'); }

function addInstanceToHand(name) {
    if (hand.length < 3) {
        addToHand(name);
        updateLibraryUI();
        if (hand.length === 3) setTimeout(closeLibrary, 200);
    }
}

function handleLongPress(name) {
    const count = hand.filter(h => h.name === name).length;
    if (count > 0) {
        if (confirm(`ç¢ºå®šè¦æ¸…é™¤å·²é¸çš„ ${count} å€‹æ­¤æ–¹å¡Šå—ï¼Ÿ`)) {
            hand = hand.filter(h => h.name !== name);
            renderHand(); updateLibraryUI(); resetSolution();
        }
    }
}

function updateLibraryUI() {
    const libPieces = document.querySelectorAll('.lib-piece');
    libPieces.forEach(div => {
        const name = div.dataset.name;
        const count = hand.filter(h => h.name === name).length;
        const badge = div.querySelector('.count-badge');
        if (count > 0) {
            div.classList.add('selected');
            badge.innerText = 'x' + count;
            badge.style.display = 'block';
        } else {
            div.classList.remove('selected');
            badge.style.display = 'none';
        }
    });
    selCountEl.innerText = hand.length;
}

// ==================== ç›¤é¢æ»‘å‹• (Lockdown) ====================
function lockBoard(locked) {
    if (locked) boardWrapper.classList.add('locked');
    else boardWrapper.classList.remove('locked');
}

function saveState() {
    boardHistory.push({
        board: JSON.parse(JSON.stringify(board)),
        newlyPlaced: JSON.parse(JSON.stringify(newlyPlacedCells))
    });
    if(boardHistory.length > 20) boardHistory.shift();
}

function updateCell(r, c) {
    if (board[r][c] !== paintMode) {
        board[r][c] = paintMode;
        newlyPlacedCells = newlyPlacedCells.filter(p => !(p.r === r && p.c === c));
        renderBoard(); resetSolution();
    }
}

function onPointerDown(e) {
    if (solutionSteps.length > 0) return;
    if (e.type === 'touchstart' && e.touches.length > 1) return;
    if (e.cancelable) e.preventDefault(); // ç¦æ­¢ç€è¦½å™¨è™•ç†

    isDragging = true;
    const r = parseInt(this.dataset.r);
    const c = parseInt(this.dataset.c);
    
    saveState();
    paintMode = 1 - board[r][c];
    updateCell(r, c);
}

function onPointerEnter(e) {
    if (solutionSteps.length > 0) return; 
    if (isDragging) {
        const r = parseInt(this.dataset.r);
        const c = parseInt(this.dataset.c);
        updateCell(r, c);
    }
}

function onTouchMove(e) {
    if (solutionSteps.length > 0) return; 
    if (!isDragging) return;
    if (e.cancelable) e.preventDefault(); // é€™è£¡å†æ¬¡ç¢ºä¿ä¸æ²å‹•
    
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (target && target.classList.contains('cell')) {
        const r = parseInt(target.dataset.r);
        const c = parseInt(target.dataset.c);
        updateCell(r, c);
    }
}

function clearBoard() {
    saveState();
    board = Array(8).fill().map(() => Array(8).fill(0));
    newlyPlacedCells = [];
    renderBoard(); resetSolution(); lockBoard(false); 
}

function undoBoard() {
    if (boardHistory.length > 0) {
        const state = boardHistory.pop();
        board = state.board;
        newlyPlacedCells = state.newlyPlaced || [];
        renderBoard(); resetSolution(); lockBoard(false); 
    }
}

function addToHand(name) {
    if (hand.length >= 3) return;
    hand.push({ name: name, shape: SHAPES[name] });
    renderHand(); resetSolution();
}

function removeFromHand(idx) {
    hand.splice(idx, 1);
    renderHand(); updateLibraryUI(); resetSolution();
}

// ==================== ç®—æ³• ====================
function resetSolution() {
    solutionSteps = [];
    currentStepIdx = 0;
    statusEl.innerText = '';
    btnNext.disabled = true;
    btnNext.innerText = "åŸ·è¡Œé€™ä¸€æ­¥ â–¶";
    const previews = document.querySelectorAll('.cell.preview');
    previews.forEach(el => { el.classList.remove('preview'); el.innerText = ''; });
    lockBoard(false); 
}

function solve(currentBoard, pieces) {
    let bestSol = null; let maxCleared = -1;
    function* permutations(arr) {
        if (arr.length <= 1) yield arr;
        else {
            for (let i = 0; i < arr.length; i++) {
                const rest = arr.slice(0, i).concat(arr.slice(i + 1));
                for (const p of permutations(rest)) yield [arr[i], ...p];
            }
        }
    }
    function canPlace(b, piece, r, c) {
        const rows = piece.length; const cols = piece[0].length;
        if (r + rows > 8 || c + cols > 8) return false;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (piece[i][j] === 1 && b[r + i][c + j] === 1) return false;
            }
        }
        return true;
    }
    function placeAndClear(b, piece, r, c) {
        let newB = b.map(row => [...row]);
        const rows = piece.length; const cols = piece[0].length;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) { if (piece[i][j]) newB[r + i][c + j] = 1; }
        }
        let clearR = [], clearC = [];
        for(let i=0; i<8; i++) if(newB[i].every(v=>v===1)) clearR.push(i);
        for(let j=0; j<8; j++) if(newB.every(row=>row[j]===1)) clearC.push(j);
        let cleared = clearR.length + clearC.length;
        if (cleared > 0) {
            for(let row of clearR) for(let j=0; j<8; j++) newB[row][j] = 0;
            for(let col of clearC) for(let i=0; i<8; i++) newB[i][col] = 0;
        }
        return { board: newB, cleared: cleared };
    }
    function backtrack(b, remainingPieces, path, totalCleared) {
        if (remainingPieces.length === 0) {
            if (totalCleared > maxCleared) { maxCleared = totalCleared; bestSol = [...path]; }
            return;
        }
        if (bestSol && maxCleared >= 5) return; 
        const current = remainingPieces[0];
        const rest = remainingPieces.slice(1);
        const shape = current.shape;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (canPlace(b, shape, r, c)) {
                    const res = placeAndClear(b, shape, r, c);
                    path.push({ name: current.name, r, c, cleared: res.cleared, shape });
                    backtrack(res.board, rest, path, totalCleared + res.cleared);
                    path.pop();
                    if (bestSol) return; 
                }
            }
        }
    }
    const perms = permutations(pieces);
    for (const p of perms) { backtrack(currentBoard, p, [], 0); if (bestSol) break; }
    return bestSol;
}

function runSolver() {
    if (hand.length === 0) { statusEl.innerText = "è«‹å…ˆé¸æ“‡æ–¹å¡Šï¼"; return; }
    statusEl.innerText = "è¨ˆç®—ä¸­...";
    setTimeout(() => {
        const sol = solve(board, hand);
        if (sol) { solutionSteps = sol; currentStepIdx = 0; previewStep(); }
        else { statusEl.innerText = "âŒ ç„¡è§£ï¼"; }
    }, 50);
}

function previewStep() {
    if (currentStepIdx >= solutionSteps.length) {
        statusEl.innerText = "ğŸ‰ å®Œæˆï¼"; statusEl.style.color = "#2ECC71";
        btnNext.disabled = true; btnNext.innerText = "å®Œæˆ";
        hand = []; renderHand(); newlyPlacedCells = []; renderBoard();
        document.querySelectorAll('.cell.preview').forEach(el => { el.classList.remove('preview'); el.innerText = ''; });
        lockBoard(false); return;
    }
    lockBoard(true);
    const step = solutionSteps[currentStepIdx];
    statusEl.innerText = `æ­¥é©Ÿ ${currentStepIdx + 1}: æ¶ˆ ${step.cleared} è¡Œ`;
    statusEl.style.color = "#F1C40F";
    btnNext.disabled = false; btnNext.innerText = "åŸ·è¡Œé€™ä¸€æ­¥ â–¶";
    document.querySelectorAll('.cell').forEach(c => { c.classList.remove('preview'); c.innerText = ''; });
    const shape = step.shape;
    const cells = document.querySelectorAll('.cell');
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if (shape[i][j]) {
                const idx = (step.r + i) * 8 + (step.c + j);
                if (cells[idx]) { cells[idx].classList.add('preview'); cells[idx].innerText = currentStepIdx + 1; }
            }
        }
    }
}

function applyNextStep() {
    if (currentStepIdx >= solutionSteps.length) return;
    const step = solutionSteps[currentStepIdx];
    saveState();
    for(let i=0; i<step.shape.length; i++) {
        for(let j=0; j<step.shape[0].length; j++) {
            if (step.shape[i][j]) {
                const r = step.r + i; const c = step.c + j;
                board[r][c] = 1; newlyPlacedCells.push({r, c});
            }
        }
    }
    let clearR = [], clearC = [];
    for(let i=0; i<8; i++) if(board[i].every(v=>v===1)) clearR.push(i);
    for(let j=0; j<8; j++) if(board.every(row=>row[j]===1)) clearC.push(j);
    if (clearR.length > 0 || clearC.length > 0) {
        for(let row of clearR) for(let j=0; j<8; j++) { board[row][j] = 0; newlyPlacedCells = newlyPlacedCells.filter(p => !(p.r === row && p.c === j)); }
        for(let col of clearC) for(let i=0; i<8; i++) { board[i][col] = 0; newlyPlacedCells = newlyPlacedCells.filter(p => !(p.r === i && p.c === col)); }
    }
    renderBoard(); currentStepIdx++; previewStep();
}

init();
</script>
</body>
</html>
